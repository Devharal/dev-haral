---
title: "Kubernetes From Zero to Production Deployment"
publishedAt: "2025-12-18"
updatedAt: "2025-12-18"
author: "Dev Haral"
summary: "A beginner-to-advanced guide that teaches Kubernetes from absolute basics to deploying production-ready workloads on AWS EKS."
image: "https://avatars.githubusercontent.com/u/90788942?v=4"
---

Kubernetes looks terrifying â€” YAML everywhere, weird names, too many concepts.
But once the mental model clicks, Kubernetes becomes the most powerful deployment system youâ€™ll ever use.

This guide starts from absolute zero and ends with deploying a production-ready app on AWS EKS.
No prior Kubernetes knowledge assumed.

---
## Why Kubernetes Exists (The Real Problem)

Docker solved packaging.
But teams quickly hit new problems:

- How do we run hundreds of containers?
- What if a container crashes?
- How do we scale traffic automatically?
- How do services discover each other?
- How do we deploy with zero downtime?

Kubernetes answers all of this.

> Kubernetes is an operating system for containers.

---
## What Is Kubernetes?

Kubernetes (K8s) is a container orchestration platform that:

- Runs Docker containers
- Manages scaling and healing
- Handles networking and load balancing
- Enables declarative deployments

You tell Kubernetes what you want.
It continuously works to keep reality matching your intent.

---
## Core Kubernetes Architecture

- Control Plane: API Server, Scheduler, Controller Manager, etcd
- Worker Nodes: kubelet, container runtime, Pods

---
## Kubernetes Mental Model

Pod = smallest deployable unit  
Deployment = manages Pods  
Service = stable networking  
Ingress = external HTTP access  
ConfigMap = non-secret config  
Secret = sensitive data  
HPA = auto scaling  

---
## Installing Kubernetes Locally (Minikube)

```bash
curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
chmod +x kubectl
sudo mv kubectl /usr/local/bin/

curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

minikube start
kubectl get nodes
```

---
## Demo App (Node.js)

```js
const express = require("express");
const app = express();

app.get("/", (req, res) => res.send("Hello from Kubernetes ðŸš€"));

app.listen(3000, () => console.log("Running on port 3000"));
```

---
## Dockerfile

```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
EXPOSE 3000
CMD ["node", "index.js"]
```

---
## Kubernetes Deployment

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
        - name: app
          image: my-k8s-app
          ports:
            - containerPort: 3000
```

---
## Service

```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  selector:
    app: my-app
  ports:
    - port: 80
      targetPort: 3000
  type: ClusterIP
```

---
## Ingress

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: my-app-ingress
spec:
  rules:
    - host: myapp.local
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: my-app-service
                port:
                  number: 80
```

---
## ConfigMap

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  NODE_ENV: production
```

---
## Secret

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: app-secret
type: Opaque
data:
  DB_PASSWORD: cGFzc3dvcmQ=
```

---
## Health Checks

```yaml
livenessProbe:
  httpGet:
    path: /
    port: 3000
  initialDelaySeconds: 10
  periodSeconds: 10

readinessProbe:
  httpGet:
    path: /
    port: 3000
  initialDelaySeconds: 5
  periodSeconds: 5
```

---
## Horizontal Pod Autoscaler

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: my-app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: my-app
  minReplicas: 2
  maxReplicas: 10
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 60
```

---
## AWS EKS Deployment

```bash
aws eks create-cluster --name my-cluster
aws eks update-kubeconfig --name my-cluster
kubectl apply -f k8s/
```

---
## Final Mental Model

Build once. Run anywhere.

Laptop â†’ Minikube â†’ AWS EKS

---
## Wrap Up

If you understand Pods, Deployments, Services, Ingress, ConfigMaps, Secrets, HPA, and EKS,
you already know real-world Kubernetes.
